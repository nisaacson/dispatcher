{
  "name": "upnode",
  "description": "transactional connection queue for dnode",
  "version": "0.3.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/upnode.git"
  },
  "main": "index.js",
  "keywords": [
    "dnode",
    "queue",
    "message",
    "reconnect",
    "transaction",
    "interruption"
  ],
  "directories": {
    "lib": ".",
    "example": "example",
    "test": "test"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "dependencies": {
    "dnode": "~1.0.1"
  },
  "devDependencies": {
    "tap": "~0.2.6"
  },
  "engines": {
    "node": ">=0.4.0"
  },
  "license": "MIT",
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "readme": "upnode\n======\n\nKeep a dnode connection alive and re-establish state between reconnects\nwith a transactional message queue.\n\n[![build status](https://secure.travis-ci.org/substack/upnode.png)](http://travis-ci.org/substack/upnode)\n\nexamples\n========\n\nsimple service interruption\n---------------------------\n\nserver.js:\n\n``` js\nvar upnode = require('upnode');\n\nvar server = upnode(function (client, conn) {\n    this.time = function (cb) { cb(new Date().toString()) };\n});\nserver.listen(7000);\n```\n\nNow when you want to make a call to the server, guard your connection in the\n`up()` function. If the connection is alive the callback fires immediately.\nIf the connection is down the callback is buffered and fires when the connection\nis ready again.\n\nclient.js:\n\n``` js\nvar upnode = require('upnode');\nvar up = upnode.connect(7000);\n\nsetInterval(function () {\n    up(function (remote) {\n        remote.time(function (t) {\n            console.log('time = ' + t);\n        });\n    });\n}, 1000);\n```\n\nIf we fire the client up first, then wait a few seconds to fire up the server:\n\n```\n$ node client.js & sleep 5; node server.js\n[1] 9165\ntime = Fri Dec 16 2011 23:47:48 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:48 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:48 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:48 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:48 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:49 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:50 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:51 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:47:52 GMT-0800 (PST)\n```\n\nwe can see that the first 5 seconds worth of requests are buffered and all come\nthrough at `23:47:48`. The requests then come in one per second once the\nconnection has been established.\n\nIf we kill the server and bring it back again while the client is running we can\nobserve a similar discontinuity as all the pending requests come through at `23:50:20`:\n\n```\n$ node client.js \ntime = Fri Dec 16 2011 23:50:11 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:11 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:12 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:13 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:20 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:21 GMT-0800 (PST)\ntime = Fri Dec 16 2011 23:50:22 GMT-0800 (PST)\n```\n\nauthenticated interruption\n--------------------------\n\nOftentimes you'll want to re-establish state between reconnection attempts.\n\nSuppose we have a simple dnode server with a `beep` function protected behind an\n`auth` function:\n\nserver.js:\n\n``` js\nvar upnode = require('upnode');\n\nvar server = upnode(function (client, conn) {\n    this.auth = function (user, pass, cb) {\n        if (user === 'moo' && pass === 'hax') {\n            cb(null, {\n                beep : function (fn) { fn('boop at ' + new Date) }\n            });\n        }\n        else cb('ACCESS DENIED')\n    };\n});\nserver.listen(7000);\n```\n\nNow instead of doing `remote.auth()` every time the connection drops, we can\npass in a callback to `upnode.connect()` that will handle the re-authentication\nand expose the authenticated object to the `up()` transaction:\n\nclient.js:\n\n``` js\nvar upnode = require('upnode');\nvar up = upnode.connect(7000, function (remote, conn) {\n    remote.auth('moo', 'hax', function (err, res) {\n        if (err) console.error(err)\n        else conn.emit('up', res)\n    });\n});\n\nsetInterval(function () {\n    up(function (remote) {\n        remote.beep(function (s) {\n            console.log(s);\n        });\n    });\n}, 1000);\n```\n\nNow spin up the client.js and the server.js:\n\n```\n$ node client.js & sleep 2; node server.js\n[1] 10892\nboop at Sat Dec 17 2011 01:30:15 GMT-0800 (PST)\nboop at Sat Dec 17 2011 01:30:15 GMT-0800 (PST)\nboop at Sat Dec 17 2011 01:30:16 GMT-0800 (PST)\nboop at Sat Dec 17 2011 01:30:17 GMT-0800 (PST)\nboop at Sat Dec 17 2011 01:30:18 GMT-0800 (PST)\n```\n\nKill the server a few times and observe that the client re-authenticates between\nreconnects.\n\nYou could do any other sort of stateful operation here besides authentication.\nJust emit the object you want to expose to `up()` through\n`conn.emit('up', obj)`.\n\nmethods\n=======\n\nvar upnode = require('upnode')\n\nvar up = upnode(constructor={}).connect(...)\n--------------------------------------------\n\nEstablish a new dnode-style connection with the dnode function or object\n`constructor` and the connection parameters which may contain host strings, port\nnumbers, option objects, and a connection callback in any order.\n\nReturns a transaction function `up()` for the connection.\n\nThe `up` object emits `\"up\"` when the link is established, `\"down\" when the link\nis severed, and `\"reconnect\"` for each reconnection attempt.\n\nIf you give `.connect()` a callback, you *must* emit an `'up', remote` event on\nthe `conn` object with the remote object you want to make available to the\nsubsequent `up()` transactions.\n\nIf you don't pass a callback to `.connect()` this default callback is used:\n\n``` js\nfunction (remote, conn) {\n    conn.emit('up', remote);\n}\n```\n\nThe callback must emit an `'up'` event so that state can be rebuilt between\nconnection interruptions. A great use for this behavior is authentication where\ncertain functionality is only made available through the callback to a\n`.auth(username, password, cb)` function on the remote. For that case you could\nwrite a connection callback that looks like:\n\n``` js\nfunction (remote, conn) {\n    remote.auth(user, pass, function (err, obj) {\n        if (err) console.error(err)\n        else conn.emit('up', obj)\n    });\n}\n```\n\nand your dnode sessions will be re-authenticated between reconnects. The remote\nobject handle in `up()` will be the `obj` result provided by the `auth()`\ncallback.\n\nBesides being passed directly to dnode's `.connect(...)`, these additional\noption-object arguments are respected:\n\n* ping - Interval in milliseconds to send pings to the remote server.\n    Default 10000. Set to 0 to disable pings.\n* timeout - Time in milliseconds to wait for a ping response before triggering a\n    reconnect. Default 5000.\n* reconnect - Time in milliseconds to wait between reconnection attempts.\n    Default 1000.\n\nvar up = upnode.connect(...)\n----------------------------\n\nShortcut for `upnode({}).connect(...)` like how `dnode.connect(...)` is a\nshortcut for `dnode({}).connect(...)`.\n\nup(timeout=0, cb)\n-----------------\n\nCreate a new transaction from the callback `cb`.\n\nIf the connection is ready, `cb(remote, conn)` will fire immediately.\nOtherwise `cb` will be queued until the connection is available again.\n\nIf `timeout` is specified, fire `cb()` after `timeout` milliseconds with no\narguments. Here's an example of using timeouts:\n\n``` js\nup(5000, function (remote) {\n    if (!remote) console.error('resource timed out')\n    else remote.beep()\n})\n```\n\nup.close()\n----------\n\nClose the connection and don't attempt to reconnect.\n\nupnode(cons).listen(...)\n------------------------\n\nCreate and return a new dnode server with ping enabled.\nIf periodic pings aren't going through the connection will be dropped and\nre-established automatically.\n\ninstall\n=======\n\nWith [npm](http://npmjs.org) do:\n\n    npm install upnode\n\nlicense\n=======\n\nMIT/X11\n",
  "readmeFilename": "README.markdown",
  "_id": "upnode@0.3.1",
  "_from": "upnode@~0.3.1"
}
